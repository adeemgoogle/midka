package go_bonus_test

import (
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/your/package/internal/models"
	"github.com/your/package/go_bonus"
)

type MockMarksLogger struct{}

func (m *MockMarksLogger) LogStudentMarks(marks []*models.StudentMark, markLoadDateString string, bonus *models.Bonus) error {
	return nil
}

type MockSaramaProducer struct {
	mock.Mock
}

func (m *MockSaramaProducer) SendMessage(msg *sarama.ProducerMessage) (partition int32, offset int64, err error) {
	args := m.Called(msg)
	return args.Int32(0), args.Int64(1), args.Error(2)
}

func TestRedeemBonus(t *testing.T) {
	mockLogger := &MockMarksLogger{}
	mockProducer := &MockSaramaProducer{}

	s := &go_bonus.BonusRedeemer{
		marksLogger: mockLogger,
		producer:    mockProducer,
	}

	// Создаем тестовые данные
	student := &models.StudentWithMarks{
		Marks: []*models.StudentMark{
			{
				KundelikID:     "1000003352507",
				MarkDateString: "2024-02-07 08:58:23.000000",
				SubjectID:      "1208089952166536233",
				GroupParallel:  6,
			},
		},
		Student: models.Student{
			KundelikID: "1000003352507",
			OwClientID: "288154590",
			CreatedAt:  time.Date(2024, time.February, 9, 14, 19, 7, 560389, time.UTC),
		},
	}

	// Ожидаем вызов функции SendMessage
	mockProducer.On("SendMessage", mock.Anything).Return(int32(0), int64(0), nil)

	// Вызываем функцию, которую мы тестируем
	err := s.RedeemBonus(student)

	// Проверяем, что функция не возвращает ошибку
	assert.NoError(t, err)

	// Проверяем, что функция SendMessage была вызвана с правильными аргументами
	mockProducer.AssertCalled(t, "SendMessage", mock.Anything)
}


это моя тестируемая функция
func (s *BonusRedeemer) RedeemBonus(student *models.StudentWithMarks) error {
	bonusAmount := len(student.Marks) * config.Get().BonusAmount

	bonus := &models.Bonus{
		Amount:     bonusAmount,
		OwClientId: student.OwClientID,
		KundelikId: student.KundelikID,
	}
_, _, err = broker.SendMessage(config.Get().KafkaTopic, msg)

	return err
}
это мой тест
package go_bonus

import (
	"github.com/stretchr/testify/require"
	_ "github.com/stretchr/testify/require"
	"mark-worker/internal/models"
	"mark-worker/pkg/config"
	"testing"
	"time"
)

type MockMarksLogger interface {
	LogStudentMarks(marks []*models.StudentMark, markLoadDateString string, bonus *models.Bonus) error
}

type MockBonusRedeemer struct {
	marksLogger MarksLogger
}

func (m MockBonusRedeemer) LogStudentMarks(marks []*models.StudentMark, markLoadDateString string, bonus *models.Bonus) error {
	return nil
}

func TestRedeemBonus(t *testing.T) {
	s := &BonusRedeemer{
		marksLogger: &MockBonusRedeemer{},
	}
	config.Parse()

	student := models.StudentWithMarks{
		Marks: []*models.StudentMark{
			{
				KundelikID:     "1000003352507",
				MarkDateString: "2024-02-07 08:58:23.000000",
				SubjectID:      "1208089952166536233",
				GroupParallel:  6,
			},
		},
		Student: models.Student{
			KundelikID: "1000003352507",
			OwClientID: "288154590",
			CreatedAt:  time.Date(2024, time.February, 9, 14, 19, 7, 560389, time.UTC),
		},
	}

	err := s.RedeemBonus(&student)
	require.NoError(t, err)
}

это моя функция
func SendMessage(topic string, message []byte) (int32, int64, error) {
	newMessage := &sarama.ProducerMessage{
		Topic: topic,
		Value: sarama.ByteEncoder(message),
	}

	partition, offset, err := producer.SendMessage(newMessage)
	if err != nil {
		log.Println("failed to send message to kafka", "error", err)
		return 0, 0, err
	}

	return partition, offset, nil
}

это мне надо замокать

_, _, err = broker.SendMessage(config.Get().KafkaTopic, msg)
