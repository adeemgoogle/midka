package kafka

import (
	"Kafka/internal/model"
	"context"
	"encoding/json"
	"github.com/ThreeDotsLabs/watermill"
	"github.com/ThreeDotsLabs/watermill/message"
	"github.com/ThreeDotsLabs/watermill/message/router/middleware"
	"github.com/ThreeDotsLabs/watermill/message/router/plugin"
	"github.com/hashicorp/go-hclog"
	"time"
)

type KafkaI interface {
	ReadTopic() (err error)
}

type Service struct {
	logger        hclog.Logger
	username      string
	password      string
	brokers       string
	consumerGroup string
	topic         string
}

func NewKafka(logger hclog.Logger, username string, password string, brokers string, consumerGroup string, topic string) KafkaI {
	return &Service{
		logger:        logger,
		username:      username,
		password:      password,
		brokers:       brokers,
		consumerGroup: consumerGroup,
		topic:         topic,
	}
}

func (s *Service) ReadTopic() (err error) {

	router, err := message.NewRouter(message.RouterConfig{}, watermill.NewStdLogger(false, false))
	if err != nil {
		return err
	}

	subscriber, err := NewKafkaConsumer(s.username, s.password, s.brokers, s.consumerGroup)
	if err != nil {
		panic(err)
	}

	router.AddPlugin(plugin.SignalsHandler)

	router.AddMiddleware(
		middleware.CorrelationID,

		middleware.Retry{
			MaxRetries:      3,
			InitialInterval: time.Millisecond * 100,
			Logger:          watermill.NewStdLogger(false, false),
		}.Middleware,

		middleware.Recoverer,
	)

	router.AddNoPublisherHandler(
		s.topic,
		s.topic,
		subscriber.Consumer,
		s.HandlerKafka,
	)

	ctx := context.Background()
	if err := router.Run(ctx); err != nil {
		s.logger.Error("Failed run router", err)
		return err
	}

	return nil
}
func (s *Service) HandlerKafka(msg *message.Message) error {
	s.logger.Info("received message", msg.UUID, string(msg.Payload))
	ans := new(model.Ans)
	if err := json.Unmarshal(msg.Payload, &ans); err != nil {
		return err
	}

	return nil
}


package kafka

import (
	"crypto/tls"
	"github.com/Shopify/sarama"
	"github.com/ThreeDotsLabs/watermill"
	"github.com/ThreeDotsLabs/watermill-kafka/v2/pkg/kafka"
	"strings"
)

type Kafka struct {
	Consumer *kafka.Subscriber
}

func NewKafkaConsumer(username string, password string, brokers string, consumerGroup string) (*Kafka, error) {
	saramaSubscriberConfig := kafka.DefaultSaramaSubscriberConfig()
	saramaSubscriberConfig.Consumer.Offsets.Initial = sarama.OffsetOldest
	if username != "" {
		saramaSubscriberConfig.Net.SASL.Enable = true
		saramaSubscriberConfig.Net.SASL.User = username
		saramaSubscriberConfig.Net.SASL.Password = password
		saramaSubscriberConfig.Net.SASL.Handshake = true
		saramaSubscriberConfig.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient { return &XDGSCRAMClient{HashGeneratorFcn: SHA256} }
		saramaSubscriberConfig.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA256
		saramaSubscriberConfig.Net.TLS.Enable = true
		saramaSubscriberConfig.Net.TLS.Config = &tls.Config{
			InsecureSkipVerify: true,
		}
	}
	saramaSubscriberConfig.Consumer.Return.Errors = true
	subscriber, err := kafka.NewSubscriber(
		kafka.SubscriberConfig{
			Brokers:               strings.Split(brokers, ","),
			Unmarshaler:           kafka.DefaultMarshaler{},
			OverwriteSaramaConfig: saramaSubscriberConfig,
			ConsumerGroup:         consumerGroup,
		},

		watermill.NewStdLogger(false, false),
	)

	if err != nil {
		panic(err)
	}

	return &Kafka{
		Consumer: subscriber,
	}, nil
}
