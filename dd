package main

import (
	"database/sql"
	"fmt"
	"log"
	"strings"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

func main() {
	// Подключение к Oracle и PostgreSQL
	oracleDB := ConnectOracle()
	postgreDB := ConnectPostgreSQL()

	if oracleDB == nil || postgreDB == nil {
		log.Fatal("Failed to connect to databases")
	}

	defer oracleDB.Close()
	defer postgreDB.Close()

	// Получение данных о банкоматах из Oracle
	atms, err := GetATMsFromOracle(oracleDB)
	if err != nil {
		log.Fatalf("Failed to get ATM data from Oracle: %v", err)
	}

	// Добавление данных о банкоматах в PostgreSQL
	err = AddATMsToPostgreSQL(postgreDB, atms)
	if err != nil {
		log.Fatalf("Failed to add ATM data to PostgreSQL: %v", err)
	}
	log.Println("ATM data added successfully")

	// Получение данных о филиалах из Oracle
	branches, err := GetBranchesFromOracle(oracleDB)
	if err != nil {
		log.Fatalf("Failed to get branch data from Oracle: %v", err)
	}

	// Добавление данных о филиалах в PostgreSQL
	err = AddBranchesToPostgreSQL(postgreDB, branches)
	if err != nil {
		log.Fatalf("Failed to add branch data to PostgreSQL: %v", err)
	}
	log.Println("Branch data added successfully")
}

// ConnectOracle подключается к Oracle базе данных
func ConnectOracle() *sql.DB {
	db, err := sql.Open("oracle", "username:password@hostname:1521/service_name")
	if err != nil {
		log.Fatalf("Failed to connect to Oracle: %v", err)
	}
	return db
}

// ConnectPostgreSQL подключается к PostgreSQL базе данных
func ConnectPostgreSQL() *sqlx.DB {
	db, err := sqlx.Open("postgres", "host=localhost port=5432 user=username password=password dbname=database_name sslmode=disable")
	if err != nil {
		log.Fatalf("Failed to connect to PostgreSQL: %v", err)
	}
	return db
}

// GetATMsFromOracle получает данные о банкоматах из Oracle
func GetATMsFromOracle(db *sql.DB) ([]ATM, error) {
	var atms []ATM
	query := `
		SELECT ANLN1 AS id, GSBER_TEXT AS filial, KATO AS locality, ADDR_RU || P_ADDR_RU || ADDR_RUS AS address,
		ADDR_KAZ || P_ADDR_KAZ || ADDR6 AS address_kaz, LOCATION_COMMENT AS location, SIGN_CASH AS cashin_flag,
		SIGN_PUBLIC AS public_flag, SIGN_ALL_DAY AS allday_flag, TIME_WORK_B AS start_time, TIME_WORK_E AS end_time,
		TIME_WORK_OB AS lunch_start, TIME_WORK_OE AS lunch_end, TIME_SUB_B AS sat_start_time, TIME_SUB_E AS sat_end_time,
		TIME_SUB_OB AS sat_lunch_start, TIME_SUB_OE AS sat_lunch_end, TIME_VOS_B AS sun_start_time, TIME_VOS_E AS sun_end_time,
		TIME_VOS_OB AS sun_lunch_start, TIME_VOS_OE AS sun_lunch_end, RECEPT_CUR AS cashin_currency, ISSUE_CUR AS currency,
		WIDTH AS lat, HEIGHT AS lng
		FROM sapprd.zwd_0033_main
		WHERE DEAKT <> 'X'
	`
	rows, err := db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var atm ATM
		err := rows.Scan(&atm.ID, &atm.Filial, &atm.Locality, &atm.Address, &atm.AddressKaz, &atm.Location,
			&atm.CashInFlag, &atm.PublicFlag, &atm.AllDayFlag, &atm.WeekdayTime.StartTime, &atm.WeekdayTime.EndTime,
			&atm.WeekdayTime.LunchStart, &atm.WeekdayTime.LunchEnd, &atm.SaturdayWorkTime.StartTime, &atm.SaturdayWorkTime.EndTime,
			&atm.SaturdayWorkTime.LunchStart, &atm.SaturdayWorkTime.LunchEnd, &atm.SundayWorkTime.StartTime, &atm.SundayWorkTime.EndTime,
			&atm.SundayWorkTime.LunchStart, &atm.SundayWorkTime.LunchEnd, &atm.Currency, &atm.CashInCurrency,
			&atm.GetLocation.Lat, &atm.GetLocation.Lng)
		if err != nil {
			return nil, err
		}
		atms = append(atms, atm)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return atms, nil
}

// AddATMsToPostgreSQL добавляет данные о банкоматах в PostgreSQL
func AddATMsToPostgreSQL(db *sqlx.DB, atms []ATM) error {
	tx := db.MustBegin()
	stmt, err := tx.Preparex(`
		INSERT INTO atm (id, filial, locality, address, address_kaz, location, cashin_flag, public_flag, allday_flag,
		start_time, end_time, lunch_start, lunch_end, sat_start_time, sat_end_time, sat_lunch_start, sat_lunch_end,
		sun_start_time, sun_end_time, sun_lunch_start, sun_lunch_end, cashin_currency, currency, lat, lng)
		VALUES (:id, :filial, :locality, :address, :address_kaz, :location, :cashin_flag, :public_flag, :allday_flag,
		:weekday_time.start_time, :weekday_time.end_time, :weekday_time.lunch_start, :weekday_time.lunch_end,
		:saturday_work_time.start_time, :saturday_work_time.end_time, :saturday_work_time.lunch_start, :saturday_work_time.lunch_end,
		:sunday_work_time.start_time, :sunday_work_time.end_time, :sunday_work_time.lunch_start, :sunday_work_time.lunch_end,
		:cashin_currency, :currency, :lat, :lng)
	`)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, atm := range atms {
		_, err := stmt.Exec(atm)
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	return tx.Commit()
}

// GetBranchesFromOracle получает данные о филиалах из Oracle
func GetBranchesFromOracle(db *sql.DB) ([]Branch, error) {
	var branches []Branch
	query := `
		SELECT NOMER AS id, "NAME" AS name, TYPE_KP AS type, GSBER_TEXT AS filial, KATO AS locality, ADRESS_KP AS address,
		ADRES4 || ADRES5 || ADRES6 AS address_kaz, "LOCATION" AS location, SWAP AS currency_exchange_flag,
		CASE WHEN SERVICE LIKE '%ЮЛ%' THEN true ELSE false END AS corporate_entity_flag,
		CASE WHEN SERVICE LIKE '%ФЛ%' THEN true ELSE false END AS person_entity_flag,
		CASE WHEN WESTERN = '1' THEN true ELSE false END AS western_union_flag,
		CASE WHEN MONEY_GRAMM = '1' THEN true ELSE false END AS money_gramm_flag,
		CASE WHEN DEPOSITORIES = 'нет' THEN false ELSE true END AS depository_flag,
		CASE WHEN PAY_TERMINAL = '1' THEN true ELSE false END AS terminal_flag,
		CASE WHEN PREMIUM_HALYK = ' ' THEN false ELSE true END AS premium_zone_flag,
		false AS all_day_flag,
		CASE WHEN NVL(TRIM(EMBOSSER), 0) > 0 THEN true ELSE false END AS embosser,
		TIME_WORK_B AS start_time, TIME_WORK_E AS end_time, TIME_WORK_OB AS lunch_start, TIME_WORK_OE AS lunch_end,
		TIME_SUB_B AS sat_start_time, TIME_SUB_E AS sat_end_time, TIME_SUB_OB AS sat_lunch_start, TIME_SUB_OE AS sat_lunch_end,
		TIME_VOS_B AS sun_start_time, TIME_VOS_E AS sun_end_time, TIME_VOS_OB AS sun_lunch_start, TIME_VOS_OE AS sun_lunch_end,
		WIDTH AS lat, HEIGHT AS lng
		FROM sapprd.zwd_0031_main
	`
	rows, err := db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var branch Branch
		err := rows.Scan(&branch.ID, &branch.Name, &branch.Type, &branch.Filial, &branch.Locality, &branch.Address,
			&branch.AddressKaz, &branch.Location, &branch.CurrencyExchangeFlag, &branch.CorporateEntityFlag,
			&branch.PersonEntityFlag, &branch.WesternUnionFlag, &branch.MoneyGrammFlag, &
