namespace TradePointsLoader.Service
{
    public class ElasticServiceNest
    {
        private readonly ElasticClient _elasticClient;
        private readonly IConfiguration _config;

        public ElasticServiceNest(IConfiguration configuration)
        {
            _config = configuration;
            var uri = new Uri(_config.GetSection("AppSettings")["ElasticsearchUrl"]);
            Log.Information($"Elastic search URL {_config.GetSection("AppSettings")["ElasticsearchUrl"]}");
            var settings = new ConnectionSettings(uri)
                .DisableDirectStreaming()
                .RequestTimeout(TimeSpan.FromSeconds(65))
                .OnRequestCompleted(apiCallsDetails =>
                {
                    if (apiCallsDetails.RequestBodyInBytes != null &&
                        apiCallsDetails.HttpMethod == Elasticsearch.Net.HttpMethod.PUT)
                    {
                        var body = Encoding.UTF8.GetString(apiCallsDetails.RequestBodyInBytes);
                        Log.Information("Mapping body {body}", body);
                    }
                });

            _elasticClient = new ElasticClient(settings);
        }

        /// <summary>
        /// Data mapping process
        /// </summary>
        /// <param name="list"></param>
        /// <param name="indexName"></param>
        /// <param name="getObjId"></param>
        /// <typeparam name="T"></typeparam>
        /// <exception cref="Exception"></exception>
        public void ProcessData<T>(List<T> list, string indexName, Func<T, string> getObjId) where T : class
        {
            var resp = _elasticClient.Bulk(b => b
                .Index(indexName)
                .IndexMany(list)
                .RequestConfiguration(rc => rc
                    .RequestTimeout(TimeSpan.FromSeconds(65)))
            );

            if (!resp.IsValid)
            {
                SentrySdk.CaptureException(new Exception($"Data mapping response error: {resp.OriginalException}"));
                throw new Exception($"Data mapping response error: {resp.OriginalException}");
            }

            SentrySdk.AddBreadcrumb("Process Data completed", category: indexName, level: BreadcrumbLevel.Debug);
        }

        public void ProcessAlias(string newIndexName, string alias)
        {
            var indexNames = _elasticClient.GetIndicesPointingToAlias(alias);

            if (indexNames.Count != 0)
            {
                foreach (var oldIndexName in indexNames)
                {
                    if (newIndexName != oldIndexName)
                    {
                        var assignAliasToNewIndex = _elasticClient.Indices.BulkAlias(b => b
                            .Add(add => add
                                .Index(newIndexName)
                                .Alias(alias))
                            .Remove(remove => remove
                                .Index(oldIndexName)
                                .Alias(alias))
                            .Timeout(TimeSpan.FromSeconds(80)));

                        if (!assignAliasToNewIndex.IsValid)
                        {
                            var exp = new Exception();
                            if (!assignAliasToNewIndex.Acknowledged)
                            {
                                exp = new Exception("Request was not acknowledged");
                            }
                            if (assignAliasToNewIndex.ServerError != null)
                            {
                                exp = new Exception(assignAliasToNewIndex.ServerError.Error.Reason);
                            }

                            SentrySdk.CaptureException(exp);
                            Log.Error(exp, "Failed to update alias {alias}, from {oldIndexName} to {newIndexName}", alias, oldIndexName, newIndexName);
                            throw exp;
                        }

                        Log.Information("Updated alias {alias}", alias);

                        Log.Information("Finished remapping alias {alias}", alias);
                    }
                }
            }
            else
            {
                var assignAlias = _elasticClient.Indices.BulkAlias(b => b
                    .Add(add => add
                        .Index(newIndexName)
                        .Alias(alias))
                    .Timeout(65));

                Log.Information($"The added index - {newIndexName} to alias - {alias} ");
                Log.Information($"Assign alias to index: {assignAlias}");
            }

            var indexes = GetIndices(alias).FindAll(i => i != newIndexName);

            foreach (var index in indexes)
            {
                Log.Information($"index to delete {index}");
                var deleteOldIndex = _elasticClient.Indices.Delete(index, d => d.Timeout(TimeSpan.FromSeconds(80)));
                
                if (!deleteOldIndex.IsValid)
                {
                    var exp = new Exception();
                    if (!deleteOldIndex.Acknowledged)
                    {
                        exp = new Exception("Request was not acknowledged");
                    }
                    if (deleteOldIndex.ServerError != null)
                    {
                        exp = new Exception(deleteOldIndex.ServerError.Error.Reason);
                    }
                    
                    SentrySdk.CaptureException(exp);
                    Log.Error(exp, "Failed to delete {oldIndexName}", index);
                }
            }
            
            SentrySdk.AddBreadcrumb("Process Alias completed", category: newIndexName, level: BreadcrumbLevel.Debug);
        }

        public string Init<T>(string indexName) where T : class
        {
            Log.Information("Initialising elasticsearch store");
            var mapIndex = ProcessType<T>(indexName);
            Log.Information("Initialising elasticsearch store finished");

            return mapIndex;
        }

        /// <summary>
        /// Checks the index exists in the elastic, if not, then creates a new index
        /// </summary>
        /// <param name="indexName"></param>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        private string ProcessType<T>(string indexName) where T : class
        {
            var index = indexName + "-" + DateTime.Now.ToString("yyyy-MM-dd-HH");
            Log.Information($"Index name for type {indexName}", index);

            var existResp = _elasticClient.Indices.Exists(index).Exists;
            if (existResp)
            {
                Log.Information($"Index {index} exists.");
            }
            else
            {
                var resp = _elasticClient.Indices.Create(index, c => c
                    .Settings(st => st
                        .NumberOfReplicas(3))
                    .Timeout(TimeSpan.FromSeconds(65))
                    .Map<T>(m => m
                        .AutoMap()
                        .Properties(pps => pps
                            .GeoPoint(g => g
                                .Name("getLocation")
                            )
                        )
                    )
                );

                Log.Information($"Index {index} created.");
                SentrySdk.AddBreadcrumb("Init completed", category: index, level: BreadcrumbLevel.Debug);

                return index;
            }

            return index;
        }

        private List<string> GetIndices(string indexName)
        {
            Regex regex = new Regex(@"^" + indexName + @"-([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})$");
            List<string> indices = new List<string>(); 
            var res = _elasticClient.Indices.Get(new GetIndexRequest(Indices.All));
            if (res.IsValid)
            {
                foreach (var index in res.Indices)
                {
                    var match = regex.Match(index.Key.Name);
                    if (match.Success)
                    {
                        indices.Add(index.Key.Name);
                    }
                }
            }

            return indices;
        }
    }


распиши что делает данный код
