using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Quartz;
using Quartz.Impl;
using Quartz.Spi;
using Serilog;
using Serilog.Events;
using Serilog.Formatting.Compact;
using StackExchange.Redis;

namespace TradePointsLoader
{
    public class Program
    {
        private static readonly IConfiguration _config = new ConfigurationBuilder()
            .SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
            .AddJsonFile("appsettings.json")
            .AddEnvironmentVariables()
            .Build();

        public static async Task<int> Main(string[] args)
        {
            ConfigureLogging();

            try
            {
                var host = CreateHostBuilder(args).Build();
                await host.RunAsync();
                return 0;
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, "Host terminated unexpectedly");
                return 1;
            }
            finally
            {
                Log.CloseAndFlush();
            }
        }

        static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureServices((hostContext, services) =>
                {
                    ConfigureServices(services);
                })
                .UseSerilog();

        static void ConfigureServices(IServiceCollection services)
        {
            services.AddLogging();
            services.AddSingleton<IHostedService, CombinedService>();
            services.AddSingleton<RedisClient>();
            services.AddSingleton<TheirDbService>();
            services.AddSingleton<IJobFactory, SingletonJobFactory>();
            services.AddSingleton<ISchedulerFactory, StdSchedulerFactory>();
        }

        static void ConfigureLogging()
        {
            Log.Logger = new LoggerConfiguration()
                .WriteTo.Console(restrictedToMinimumLevel: LogEventLevel.Debug, formatter: new RenderedCompactJsonFormatter())
                .CreateLogger();
        }
    }
}


using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Quartz;
using Quartz.Spi;
using StackExchange.Redis;

public class CombinedService : IHostedService
{
    private readonly ILogger<CombinedService> _logger;
    private readonly IConfiguration _config;
    private readonly string[] _servers;
    private readonly string _password;
    private readonly string _serviceName;
    private readonly int _db;
    private readonly IServiceProvider _serviceProvider;
    private ConnectionMultiplexer _redis;
    private IScheduler _scheduler;

    public CombinedService(
        ILogger<CombinedService> logger,
        IConfiguration config,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _config = config;
        _serviceProvider = serviceProvider;
        _servers = config.GetSection("RedisServers").Get<string[]>();
        _password = config["RedisPassword"];
        _serviceName = config["RedisServiceName"];
        _db = int.Parse(config["RedisDB"]);
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _redis = CreateRedisClient();
        var isMaster = await CheckIfMasterAsync(cancellationToken);

        if (isMaster)
        {
            _logger.LogInformation("This instance is master.");
            await BecomeMasterAsync(cancellationToken);
        }
        else
        {
            _logger.LogInformation("This instance is slave, waiting for master to fail...");
            await MonitorMasterAsync(cancellationToken);
        }
    }

    private ConnectionMultiplexer CreateRedisClient()
    {
        return ConnectionMultiplexer.Connect(new ConfigurationOptions
        {
            EndPoints = { _servers[0] },
            Password = _password,
            DefaultDatabase = _db
        });
    }

    private async Task<bool> CheckIfMasterAsync(CancellationToken cancellationToken)
    {
        var db = _redis.GetDatabase();
        var master = await db.StringGetAsync(_serviceName);
        return string.IsNullOrEmpty(master);
    }

    private async Task BecomeMasterAsync(CancellationToken cancellationToken)
    {
        _scheduler = await CreateSchedulerAsync(cancellationToken);
        await _scheduler.Start(cancellationToken);

        while (!cancellationToken.IsCancellationRequested)
        {
            var db = _redis.GetDatabase();
            var id = Guid.NewGuid().ToString();
            await db.StringSetAsync(_serviceName, id, TimeSpan.FromSeconds(30));
            _logger.LogInformation("Updated master status with ID: {Id}", id);
            await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken);
        }
    }

    private async Task MonitorMasterAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            var isMaster = await CheckIfMasterAsync(cancellationToken);
            if (isMaster)
            {
                _logger.LogInformation("Master is dead, becoming master...");
                await BecomeMasterAsync(cancellationToken);
                break;
            }
            await Task.Delay(TimeSpan.FromSeconds(30), cancellationToken);
        }
    }

    private async Task<IScheduler> CreateSchedulerAsync(CancellationToken cancellationToken)
    {
        var factory = new StdSchedulerFactory();
        var scheduler = await factory.GetScheduler(cancellationToken);

        var job = JobBuilder.Create<UploadJob>()
            .WithIdentity("UploadJob", "group1")
            .Build();

        var trigger = TriggerBuilder.Create()
            .WithIdentity("UploadJobTrigger", "group1")
            .StartNow()
            .WithCronSchedule("0/30 * * * * ?") // Every 30 seconds for testing
            .Build();

        await scheduler.ScheduleJob(job, trigger, cancellationToken);

        return scheduler;
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        if (_scheduler != null)
        {
            await _scheduler.Shutdown(cancellationToken);
        }

        if (_redis != null)
        {
            await _redis.CloseAsync();
        }
    }
}

using System;
using Quartz;
using Quartz.Spi;

public class SingletonJobFactory : IJobFactory
{
    private readonly IServiceProvider _serviceProvider;

    public SingletonJobFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler)
    {
        return _serviceProvider.GetService(bundle.JobDetail.JobType) as IJob;
    }

    public void ReturnJob(IJob job) { }
}


using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Quartz;

public class UploadJob : IJob
{
    private readonly ILogger<UploadJob> _logger;
    private readonly IServiceProvider _serviceProvider;

    public UploadJob(ILogger<UploadJob> logger, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }

    public Task Execute(IJobExecutionContext context)
    {
        _logger.LogInformation("Started to upload information...");

        using (var scope = _serviceProvider.CreateScope())
        {
            var dbService = scope.ServiceProvider.GetRequiredService<TheirDbService>();
            var result = dbService.StealInformation();

            if (result)
            {
                _logger.LogInformation("Successful inserted data");
            }
            else
            {
                _logger.LogError("Failed to make cash");
            }
        }

        return Task.CompletedTask;
    }
}

using StackExchange.Redis;

public class RedisClient
{
    private readonly ConnectionMultiplexer _redis;

    public RedisClient(string connectionString)
    {
        _redis = ConnectionMultiplexer.Connect(connectionString);
    }

    public IDatabase GetDatabase()
    {
        return _redis.GetDatabase();
    }

    public Task<string> GetAsync(string key)
    {
        return _redis.GetDatabase().StringGetAsync(key);
    }

    public Task SetAsync(string key, string value, TimeSpan expiry)
    {
        return _redis.GetDatabase().StringSetAsync(key, value, expiry);
    }
}



{
  "RedisServers": [ "localhost:6379" ],
  "RedisPassword": "",
  "RedisServiceName": "MyRedisService",
  "RedisDB": "0",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}
